# coding: utf-8

"""
    Groupon Connect APIs

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: 3pip@groupon.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from mobidy_groupon_api.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_availability(self, product_ids, start_date, end_date, **kwargs):  # noqa: E501
        """Availability  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_availability(product_ids, start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str product_ids: Comma delimited list of product IDs.  (required)
        :param datetime start_date: Date/time specifying the beginning of the period for which segments should be provided. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param datetime end_date: Date/time specifying the end of the period for which segments should be provided. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param str merchant_id: The id of the merchant whose service availabilities should be provided.
        :param str attribute_ids: Comma delimited list of attribute IDs that further refine the availability of the products. This list should be considered an OR for related attributes. If no attribute is passed then that is considered as if all attributes are possible for availability.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_availability_with_http_info(product_ids, start_date, end_date, **kwargs)  # noqa: E501
        else:
            (data) = self.get_availability_with_http_info(product_ids, start_date, end_date, **kwargs)  # noqa: E501
            return data

    def get_availability_with_http_info(self, product_ids, start_date, end_date, **kwargs):  # noqa: E501
        """Availability  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_availability_with_http_info(product_ids, start_date, end_date, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str product_ids: Comma delimited list of product IDs.  (required)
        :param datetime start_date: Date/time specifying the beginning of the period for which segments should be provided. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param datetime end_date: Date/time specifying the end of the period for which segments should be provided. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param str merchant_id: The id of the merchant whose service availabilities should be provided.
        :param str attribute_ids: Comma delimited list of attribute IDs that further refine the availability of the products. This list should be considered an OR for related attributes. If no attribute is passed then that is considered as if all attributes are possible for availability.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['product_ids', 'start_date', 'end_date', 'merchant_id', 'attribute_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_availability" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'product_ids' is set
        if ('product_ids' not in params or
                params['product_ids'] is None):
            raise ValueError("Missing the required parameter `product_ids` when calling `get_availability`")  # noqa: E501
        # verify the required parameter 'start_date' is set
        if ('start_date' not in params or
                params['start_date'] is None):
            raise ValueError("Missing the required parameter `start_date` when calling `get_availability`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if ('end_date' not in params or
                params['end_date'] is None):
            raise ValueError("Missing the required parameter `end_date` when calling `get_availability`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'product_ids' in params:
            query_params.append(('productIds', params['product_ids']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('startDate', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('endDate', params['end_date']))  # noqa: E501
        if 'merchant_id' in params:
            query_params.append(('merchantId', params['merchant_id']))  # noqa: E501
        if 'attribute_ids' in params:
            query_params.append(('attributeIds', params['attribute_ids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/feed/availability', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_merchant_feed(self, ids, **kwargs):  # noqa: E501
        """Content  # noqa: E501

        This endpoint is used to retrieve the list of products and services that the merchant provides so that Groupon can make calls to the availability endpoints with the appropriate parameters.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_merchant_feed(ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ids: Comma delimited list of merchant ids in the partner’s system.  (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_merchant_feed_with_http_info(ids, **kwargs)  # noqa: E501
        else:
            (data) = self.get_merchant_feed_with_http_info(ids, **kwargs)  # noqa: E501
            return data

    def get_merchant_feed_with_http_info(self, ids, **kwargs):  # noqa: E501
        """Content  # noqa: E501

        This endpoint is used to retrieve the list of products and services that the merchant provides so that Groupon can make calls to the availability endpoints with the appropriate parameters.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_merchant_feed_with_http_info(ids, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str ids: Comma delimited list of merchant ids in the partner’s system.  (required)
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_merchant_feed" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'ids' is set
        if ('ids' not in params or
                params['ids'] is None):
            raise ValueError("Missing the required parameter `ids` when calling `get_merchant_feed`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'ids' in params:
            query_params.append(('ids', params['ids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/feed/services/merchants', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_reservations_id(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Retrieve Reservation  # noqa: E501

        This endpoint is used to retrieve an existing reservation created through a [reserve call](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post) from the Partner.  ## Expected SLA TP99 50ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  Note: The response body is the same as the [Reserve endpoint](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations_id(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_reservations_id_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_reservations_id_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
            return data

    def get_reservations_id_with_http_info(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Retrieve Reservation  # noqa: E501

        This endpoint is used to retrieve an existing reservation created through a [reserve call](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post) from the Partner.  ## Expected SLA TP99 50ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  Note: The response body is the same as the [Reserve endpoint](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations_id_with_http_info(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'reservation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reservations_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `get_reservations_id`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `get_reservations_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/reservations/{reservationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_service_availability(self, service_ids, start_date, end_date, merchant_id, **kwargs):  # noqa: E501
        """Booking Availability  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_availability(service_ids, start_date, end_date, merchant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_ids: Comma delimited list of service IDs.  (required)
        :param datetime start_date: Date/time specifying the beginning of the period for which segments should be provided. The results should all include availableAt date and times that are greater than or equal to this value. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param datetime end_date: Date/time specifying the end of the period for which segments should be provided. The results should all include availableAt date and times that are less than or equal to this value. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param str merchant_id: The id of the merchant whose service availabilities should be provided.  (required)
        :param str attribute_ids: Comma delimited list of attribute IDs that further refine the availability of the services. This list should be considered an OR for related attributes. If no attribute is passed then that is considered as if all attributes are possible for availability.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_service_availability_with_http_info(service_ids, start_date, end_date, merchant_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_service_availability_with_http_info(service_ids, start_date, end_date, merchant_id, **kwargs)  # noqa: E501
            return data

    def get_service_availability_with_http_info(self, service_ids, start_date, end_date, merchant_id, **kwargs):  # noqa: E501
        """Booking Availability  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_service_availability_with_http_info(service_ids, start_date, end_date, merchant_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str service_ids: Comma delimited list of service IDs.  (required)
        :param datetime start_date: Date/time specifying the beginning of the period for which segments should be provided. The results should all include availableAt date and times that are greater than or equal to this value. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param datetime end_date: Date/time specifying the end of the period for which segments should be provided. The results should all include availableAt date and times that are less than or equal to this value. The format is ISO-8601 combined date and time with timezone (also known as Internet date/time format: https://tools.ietf.org/html/rfc3339#section-5).  (required)
        :param str merchant_id: The id of the merchant whose service availabilities should be provided.  (required)
        :param str attribute_ids: Comma delimited list of attribute IDs that further refine the availability of the services. This list should be considered an OR for related attributes. If no attribute is passed then that is considered as if all attributes are possible for availability.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['service_ids', 'start_date', 'end_date', 'merchant_id', 'attribute_ids']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_service_availability" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'service_ids' is set
        if ('service_ids' not in params or
                params['service_ids'] is None):
            raise ValueError("Missing the required parameter `service_ids` when calling `get_service_availability`")  # noqa: E501
        # verify the required parameter 'start_date' is set
        if ('start_date' not in params or
                params['start_date'] is None):
            raise ValueError("Missing the required parameter `start_date` when calling `get_service_availability`")  # noqa: E501
        # verify the required parameter 'end_date' is set
        if ('end_date' not in params or
                params['end_date'] is None):
            raise ValueError("Missing the required parameter `end_date` when calling `get_service_availability`")  # noqa: E501
        # verify the required parameter 'merchant_id' is set
        if ('merchant_id' not in params or
                params['merchant_id'] is None):
            raise ValueError("Missing the required parameter `merchant_id` when calling `get_service_availability`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'service_ids' in params:
            query_params.append(('serviceIds', params['service_ids']))  # noqa: E501
        if 'start_date' in params:
            query_params.append(('startDate', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('endDate', params['end_date']))  # noqa: E501
        if 'merchant_id' in params:
            query_params.append(('merchantId', params['merchant_id']))  # noqa: E501
        if 'attribute_ids' in params:
            query_params.append(('attributeIds', params['attribute_ids']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/feed/services/availability', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_booking_availability(self, body, **kwargs):  # noqa: E501
        """Booking Availability Check  # noqa: E501

        This endpoint is used to support an availability check before booking happens.  This endpoint to pull the availability in real time. This would be used as part of UX to update enabled options when a customer is making their selections and also when purchasing, to validate again that what they want to book is still available. The request would either be the raw segment Groupon got on the feed, or it might have the specific attributes that the customer selected (a subset of the attributeIds). If multiple attributes per group are used, the segments on the response might not match the request exactly if a specific attribute isn’t available anymore, main use case would be staff members. See an example.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_booking_availability(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BookingsAvailabilityBody body: (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_booking_availability_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_booking_availability_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_booking_availability_with_http_info(self, body, **kwargs):  # noqa: E501
        """Booking Availability Check  # noqa: E501

        This endpoint is used to support an availability check before booking happens.  This endpoint to pull the availability in real time. This would be used as part of UX to update enabled options when a customer is making their selections and also when purchasing, to validate again that what they want to book is still available. The request would either be the raw segment Groupon got on the feed, or it might have the specific attributes that the customer selected (a subset of the attributeIds). If multiple attributes per group are used, the segments on the response might not match the request exactly if a specific attribute isn’t available anymore, main use case would be staff members. See an example.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_booking_availability_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BookingsAvailabilityBody body: (required)
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_booking_availability" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_booking_availability`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/bookings/availability', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_booking_cancellations(self, body, **kwargs):  # noqa: E501
        """Booking Cancellation  # noqa: E501

        This endpoint is used to support booking level cancellation.  The state of the requested bookings should be transitioned to `cancelled`. This endpoint should behave in a transactional manner, that is, if any booking in the request can't be transitioned to `cancelled` the whole request should fail with error code `BOOKING_NOT_CANCELLABLE`,  and no state transition should happen to any of the bookings.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_booking_cancellations(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BookingsCancellationsBody body: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_booking_cancellations_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_booking_cancellations_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_booking_cancellations_with_http_info(self, body, **kwargs):  # noqa: E501
        """Booking Cancellation  # noqa: E501

        This endpoint is used to support booking level cancellation.  The state of the requested bookings should be transitioned to `cancelled`. This endpoint should behave in a transactional manner, that is, if any booking in the request can't be transitioned to `cancelled` the whole request should fail with error code `BOOKING_NOT_CANCELLABLE`,  and no state transition should happen to any of the bookings.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_booking_cancellations_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param BookingsCancellationsBody body: (required)
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_booking_cancellations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_booking_cancellations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/bookings/cancellations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_booking_creation(self, body, **kwargs):  # noqa: E501
        """Create Booking  # noqa: E501

        This endpoint is used to support booking creation.  The status of the booking after this call should be `confirmed` or `hold`, depending on the `bookingType` value. This endpoint should behave in a transactional manner, that is, if any booking in the request can't be transitioned to `confirmed` the whole request should fail with error code `BOOKING_NOT_CREATED`, and no booking should be created.  This endpoint must be idempotent.  In case Groupon makes a second request with the same `grouponBookingId`, and the partner already created a booking in its system for this id, the previously created booking must be returned.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_booking_creation(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1BookingsBody body: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_booking_creation_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.post_booking_creation_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def post_booking_creation_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create Booking  # noqa: E501

        This endpoint is used to support booking creation.  The status of the booking after this call should be `confirmed` or `hold`, depending on the `bookingType` value. This endpoint should behave in a transactional manner, that is, if any booking in the request can't be transitioned to `confirmed` the whole request should fail with error code `BOOKING_NOT_CREATED`, and no booking should be created.  This endpoint must be idempotent.  In case Groupon makes a second request with the same `grouponBookingId`, and the partner already created a booking in its system for this id, the previously created booking must be returned.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_booking_creation_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1BookingsBody body: (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_booking_creation" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_booking_creation`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/bookings', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_products_availability(self, body, locale, **kwargs):  # noqa: E501
        """Availability Check  # noqa: E501

        This endpoint is used to determine availability and pricing for a specific product and attribute combination. The availability should be based off of real-time sources.  Optionally, the partner may choose to implement a temporary hold on inventory and return those reserved units in the response. For an iframe integration, the returned reservation ID (called a pre-reservation ID in this call) will be passed as a URL parameter.  A partner which is implementing only iframe transactions will not need to implement this call. However, even if a partner has “unlimited” inventory this endpoint should still be implemented. The reason is that the partner should return a `PRODUCT_NOT_AVAILABLE` error if the product is no longer offered for purchase.  ## Expected SLA TP99 35ms at 10k rpm  This is just the server response time, and does not include network transit time.  ## Request This request is specified as using POST for practical reasons as the full set of inputs may exceed static buffer space for query string size in common server stacks; however, the request should not create data, and the semantics should be the same as GET. The specific attributes supported will expand over time to fit the needs of a specific partner.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_products_availability(body, locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProductsAvailabilityBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_products_availability_with_http_info(body, locale, **kwargs)  # noqa: E501
        else:
            (data) = self.post_products_availability_with_http_info(body, locale, **kwargs)  # noqa: E501
            return data

    def post_products_availability_with_http_info(self, body, locale, **kwargs):  # noqa: E501
        """Availability Check  # noqa: E501

        This endpoint is used to determine availability and pricing for a specific product and attribute combination. The availability should be based off of real-time sources.  Optionally, the partner may choose to implement a temporary hold on inventory and return those reserved units in the response. For an iframe integration, the returned reservation ID (called a pre-reservation ID in this call) will be passed as a URL parameter.  A partner which is implementing only iframe transactions will not need to implement this call. However, even if a partner has “unlimited” inventory this endpoint should still be implemented. The reason is that the partner should return a `PRODUCT_NOT_AVAILABLE` error if the product is no longer offered for purchase.  ## Expected SLA TP99 35ms at 10k rpm  This is just the server response time, and does not include network transit time.  ## Request This request is specified as using POST for practical reasons as the full set of inputs may exceed static buffer space for query string size in common server stacks; however, the request should not create data, and the semantics should be the same as GET. The specific attributes supported will expand over time to fit the needs of a specific partner.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_products_availability_with_http_info(body, locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProductsAvailabilityBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'purchaser_id', 'prereservation_id', 'purchaser_email_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_products_availability" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_products_availability`")  # noqa: E501
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `post_products_availability`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'purchaser_id' in params:
            query_params.append(('purchaserId', params['purchaser_id']))  # noqa: E501
        if 'prereservation_id' in params:
            query_params.append(('prereservationId', params['prereservation_id']))  # noqa: E501
        if 'purchaser_email_hash' in params:
            query_params.append(('purchaserEmailHash', params['purchaser_email_hash']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/products/availability', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reservations(self, body, locale, purchaser_id, **kwargs):  # noqa: E501
        """Create Reservation  # noqa: E501

        This endpoint is used to put an indefinite hold on inventory. This can take the form of either a specific unit returned from the check availability call, or a general product. The reserved units should “belong” to the purchaser, and should not expire or be released unless cancel is explicitly called. The inventory should also not be released to the purchaser until it has been fulfilled.  In the case that a previously reserved unit (i.e. a temporary hold from the check availability call) is no longer available, this should be treated as any other availability failure.  The partner is able to verify the price Groupon is charging as it will be passed in the request. Groupon will also verify the price which the partner expected to be charged by comparing it to the price in the response. If Groupon detects an inconsistency, it may automatically cancel the order to avoid incorrectly charging the customer; however, it is recommended that the partner verify the price on the request and fail the request with the appropriate error code.  The status of the reservation after this call should be “reserved”.  ## Expected SLA TP99 80ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations(body, locale, purchaser_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1ReservationsBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).  (required)
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reservations_with_http_info(body, locale, purchaser_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reservations_with_http_info(body, locale, purchaser_id, **kwargs)  # noqa: E501
            return data

    def post_reservations_with_http_info(self, body, locale, purchaser_id, **kwargs):  # noqa: E501
        """Create Reservation  # noqa: E501

        This endpoint is used to put an indefinite hold on inventory. This can take the form of either a specific unit returned from the check availability call, or a general product. The reserved units should “belong” to the purchaser, and should not expire or be released unless cancel is explicitly called. The inventory should also not be released to the purchaser until it has been fulfilled.  In the case that a previously reserved unit (i.e. a temporary hold from the check availability call) is no longer available, this should be treated as any other availability failure.  The partner is able to verify the price Groupon is charging as it will be passed in the request. Groupon will also verify the price which the partner expected to be charged by comparing it to the price in the response. If Groupon detects an inconsistency, it may automatically cancel the order to avoid incorrectly charging the customer; however, it is recommended that the partner verify the price on the request and fail the request with the appropriate error code.  The status of the reservation after this call should be “reserved”.  ## Expected SLA TP99 80ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_with_http_info(body, locale, purchaser_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1ReservationsBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).  (required)
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'purchaser_id', 'prereservation_id', 'purchaser_email_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reservations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_reservations`")  # noqa: E501
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `post_reservations`")  # noqa: E501
        # verify the required parameter 'purchaser_id' is set
        if ('purchaser_id' not in params or
                params['purchaser_id'] is None):
            raise ValueError("Missing the required parameter `purchaser_id` when calling `post_reservations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'purchaser_id' in params:
            query_params.append(('purchaserId', params['purchaser_id']))  # noqa: E501
        if 'prereservation_id' in params:
            query_params.append(('prereservationId', params['prereservation_id']))  # noqa: E501
        if 'purchaser_email_hash' in params:
            query_params.append(('purchaserEmailHash', params['purchaser_email_hash']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/reservations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reservations_id_cancellations(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Cancellation  # noqa: E501

        This endpoint is to transition a reservation in the “reserved” or “fulfilled” state to the “cancelled” state. This indicates that the reservation is now void, and should not be fulfilled or redeemed for the consumer. A variety of circumstances could cause this, but the important distinction for a partner is that it should not allow fulfillment and/or redemption for the customer if at all possible. It is considered valid for this endpoint to be invoked on a reservation for any status; however, not all reservation are allowed to be cancelled (e.g. the reservation type does not allow cancels or the time window for cancellation has elapsed).  Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be “cancelling” or “cancelled”.   ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_cancellations(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reservations_id_cancellations_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reservations_id_cancellations_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
            return data

    def post_reservations_id_cancellations_with_http_info(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Cancellation  # noqa: E501

        This endpoint is to transition a reservation in the “reserved” or “fulfilled” state to the “cancelled” state. This indicates that the reservation is now void, and should not be fulfilled or redeemed for the consumer. A variety of circumstances could cause this, but the important distinction for a partner is that it should not allow fulfillment and/or redemption for the customer if at all possible. It is considered valid for this endpoint to be invoked on a reservation for any status; however, not all reservation are allowed to be cancelled (e.g. the reservation type does not allow cancels or the time window for cancellation has elapsed).  Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be “cancelling” or “cancelled”.   ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_cancellations_with_http_info(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'reservation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reservations_id_cancellations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `post_reservations_id_cancellations`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `post_reservations_id_cancellations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/reservations/{reservationId}/cancellations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reservations_id_fulfillments(self, body, reservation_id, **kwargs):  # noqa: E501
        """Fulfillment  # noqa: E501

        This endpoint is to transition a reservation in the `reserved` state to the `fulfilled` state. This indicates that the payment has been captured by Groupon, and the reservation is now able to be fulfilled by the partner. The inventory should not be released to the user until it is fulfilled.  It is considered valid for this endpoint to be invoked on a `fulfilled` or `fulfilling` reservation, but not a `cancelled`, `cancelling`, or `reserving` reservation. Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be `fulfilling` or `fulfilled`. The status should be set to `fulfilling` until the inventory has been shipped (for shipping products) or an electronic form is available (for electronic fulfillmentType products). Once this occurs, the status can be changed to the final `fulfilled` status. The important aspect here is that the status should not be set to `fulfilled` unless the inventory has been guaranteed to be available for the purchaser.  ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed. Please note that locale is not required to be passed in this call.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_fulfillments(body, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReservationIdFulfillmentsBody body: (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reservations_id_fulfillments_with_http_info(body, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reservations_id_fulfillments_with_http_info(body, reservation_id, **kwargs)  # noqa: E501
            return data

    def post_reservations_id_fulfillments_with_http_info(self, body, reservation_id, **kwargs):  # noqa: E501
        """Fulfillment  # noqa: E501

        This endpoint is to transition a reservation in the `reserved` state to the `fulfilled` state. This indicates that the payment has been captured by Groupon, and the reservation is now able to be fulfilled by the partner. The inventory should not be released to the user until it is fulfilled.  It is considered valid for this endpoint to be invoked on a `fulfilled` or `fulfilling` reservation, but not a `cancelled`, `cancelling`, or `reserving` reservation. Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be `fulfilling` or `fulfilled`. The status should be set to `fulfilling` until the inventory has been shipped (for shipping products) or an electronic form is available (for electronic fulfillmentType products). Once this occurs, the status can be changed to the final `fulfilled` status. The important aspect here is that the status should not be set to `fulfilled` unless the inventory has been guaranteed to be available for the purchaser.  ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed. Please note that locale is not required to be passed in this call.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_fulfillments_with_http_info(body, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReservationIdFulfillmentsBody body: (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'reservation_id', 'locale']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reservations_id_fulfillments" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_reservations_id_fulfillments`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `post_reservations_id_fulfillments`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/reservations/{reservationId}/fulfillments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def webhook_bookings(self, body, client_id, partner, **kwargs):  # noqa: E501
        """Booking Status Update  # noqa: E501

        This endpoint can be used by partners to notify Groupon of bookings status updates (e.g., when a booking is cancelled on partner side).  ## SLA TP99 100ms at 10k rpm.  ## Request The request body should include a list of bookings to update.  Each entry of the list specifies the partner-generated booking id, the update of the booking (`cancelled`, `check-in`, `no-show`), and a datetime representing when the booking was last updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhook_bookings(body, client_id, partner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1BookingsBody1 body: (required)
        :param str client_id: A client id required to make the request.  This id will be provided to partners by Groupon.  (required)
        :param str partner: The partner name.  (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.webhook_bookings_with_http_info(body, client_id, partner, **kwargs)  # noqa: E501
        else:
            (data) = self.webhook_bookings_with_http_info(body, client_id, partner, **kwargs)  # noqa: E501
            return data

    def webhook_bookings_with_http_info(self, body, client_id, partner, **kwargs):  # noqa: E501
        """Booking Status Update  # noqa: E501

        This endpoint can be used by partners to notify Groupon of bookings status updates (e.g., when a booking is cancelled on partner side).  ## SLA TP99 100ms at 10k rpm.  ## Request The request body should include a list of bookings to update.  Each entry of the list specifies the partner-generated booking id, the update of the booking (`cancelled`, `check-in`, `no-show`), and a datetime representing when the booking was last updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhook_bookings_with_http_info(body, client_id, partner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1BookingsBody1 body: (required)
        :param str client_id: A client id required to make the request.  This id will be provided to partners by Groupon.  (required)
        :param str partner: The partner name.  (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'client_id', 'partner']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method webhook_bookings" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `webhook_bookings`")  # noqa: E501
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `webhook_bookings`")  # noqa: E501
        # verify the required parameter 'partner' is set
        if ('partner' not in params or
                params['partner'] is None):
            raise ValueError("Missing the required parameter `partner` when calling `webhook_bookings`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'partner' in params:
            path_params['partner'] = params['partner']  # noqa: E501

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/partners/{partner}/v1/bookings', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def webhook_reservations(self, body, client_id, partner, **kwargs):  # noqa: E501
        """Status Update  # noqa: E501

        This endpoint can be used by partners to notify Groupon of reservation status updates, when a reservation is fulfilled or cancelled on partner side.  ## SLA TP99 100ms at 10k rpm.  ## Request The request body should include a list of reservation to update.  Each entry of the list specifies the partner-generated reservation id, the new status of the reservation (`fulfilled` or `cancelled`), and a datetime representing when the reservation was last updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhook_reservations(body, client_id, partner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1ReservationsBody1 body: (required)
        :param str client_id: A client id required to make the request.  This id will be provided to partners by Groupon.  (required)
        :param str partner: The partner name.  (required)
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.webhook_reservations_with_http_info(body, client_id, partner, **kwargs)  # noqa: E501
        else:
            (data) = self.webhook_reservations_with_http_info(body, client_id, partner, **kwargs)  # noqa: E501
            return data

    def webhook_reservations_with_http_info(self, body, client_id, partner, **kwargs):  # noqa: E501
        """Status Update  # noqa: E501

        This endpoint can be used by partners to notify Groupon of reservation status updates, when a reservation is fulfilled or cancelled on partner side.  ## SLA TP99 100ms at 10k rpm.  ## Request The request body should include a list of reservation to update.  Each entry of the list specifies the partner-generated reservation id, the new status of the reservation (`fulfilled` or `cancelled`), and a datetime representing when the reservation was last updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhook_reservations_with_http_info(body, client_id, partner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1ReservationsBody1 body: (required)
        :param str client_id: A client id required to make the request.  This id will be provided to partners by Groupon.  (required)
        :param str partner: The partner name.  (required)
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'client_id', 'partner']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method webhook_reservations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `webhook_reservations`")  # noqa: E501
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `webhook_reservations`")  # noqa: E501
        # verify the required parameter 'partner' is set
        if ('partner' not in params or
                params['partner'] is None):
            raise ValueError("Missing the required parameter `partner` when calling `webhook_reservations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'partner' in params:
            path_params['partner'] = params['partner']  # noqa: E501

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/partners/{partner}/v1/reservations', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def webhook_units(self, body, client_id, partner, **kwargs):  # noqa: E501
        """Redemption  # noqa: E501

        This endpoint can be used by partners to notify Groupon of units status updates, when a unit is redeemed or cancelled on partner side.  ## SLA TP99 100ms at 10k rpm.  ## Request The request body should include a list of units to update.  Each entry of the list specifies the partner-generated unit id, the new status of the unit (`redeemed` or `cancelled`), and a datetime representing when the reservation containing the unit was last updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhook_units(body, client_id, partner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1UnitsBody body: (required)
        :param str client_id: A client id required to make the request.  This id will be provided to partners by Groupon.  (required)
        :param str partner: The partner name.  (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.webhook_units_with_http_info(body, client_id, partner, **kwargs)  # noqa: E501
        else:
            (data) = self.webhook_units_with_http_info(body, client_id, partner, **kwargs)  # noqa: E501
            return data

    def webhook_units_with_http_info(self, body, client_id, partner, **kwargs):  # noqa: E501
        """Redemption  # noqa: E501

        This endpoint can be used by partners to notify Groupon of units status updates, when a unit is redeemed or cancelled on partner side.  ## SLA TP99 100ms at 10k rpm.  ## Request The request body should include a list of units to update.  Each entry of the list specifies the partner-generated unit id, the new status of the unit (`redeemed` or `cancelled`), and a datetime representing when the reservation containing the unit was last updated.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.webhook_units_with_http_info(body, client_id, partner, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V1UnitsBody body: (required)
        :param str client_id: A client id required to make the request.  This id will be provided to partners by Groupon.  (required)
        :param str partner: The partner name.  (required)
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'client_id', 'partner']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method webhook_units" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `webhook_units`")  # noqa: E501
        # verify the required parameter 'client_id' is set
        if ('client_id' not in params or
                params['client_id'] is None):
            raise ValueError("Missing the required parameter `client_id` when calling `webhook_units`")  # noqa: E501
        # verify the required parameter 'partner' is set
        if ('partner' not in params or
                params['partner'] is None):
            raise ValueError("Missing the required parameter `partner` when calling `webhook_units`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'partner' in params:
            path_params['partner'] = params['partner']  # noqa: E501

        query_params = []
        if 'client_id' in params:
            query_params.append(('client_id', params['client_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/partners/{partner}/v1/units', 'PATCH',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
