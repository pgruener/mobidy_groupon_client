# coding: utf-8

"""
    Groupon Connect APIs

    No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)  # noqa: E501

    OpenAPI spec version: 1.0.0
    Contact: 3pip@groupon.com
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""

from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from mobidy_groupon_api.api_client import ApiClient


class TransactionalPartnerEndpointsApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def get_reservations(self, locale, updated_since, updated_until, **kwargs):  # noqa: E501
        """Search Reservations  # noqa: E501

        This endpoint is a search endpoint for Groupon to retrieve a collection of relevant reservations matching a specified query. This endpoint will be used by Groupon for post-purchase reservation status reconciliations with partner. This helps to reduce multiple calls to partner on individual reservation with Retrieve Reservation api and consolidating into fewer bulk calls.  The results should be sorted by the reservation updatedAt field in ascending order, then by the id field in ascending order. Sorting will ensure records maintain definite order across pagination queries.  To ensure Groupon polls all the updated reservations with the endpoint, the reservation updatedAt field should be updated by partner when: * Reservation status is updated * ReservedUnits associated with reservation are updated  Note: Groupon will make calls to this endpoint at recurring intervals and paginate over the results if needed.  For example if calling every 10 minutes: t: /groupon/v1/reservations?status=fulfilled&updatedSince=2018-11-04T00:00:00Z&updatedUntil=2018-11-04T00:10:00Z&limit=100&offset=0&locale=en_US t+10min: /groupon/v1/reservations?status=fulfilled&updatedSince=2018-11-04T00:10:00Z&updatedUntil=2018-11-04T00:20:00Z&limit=100&offset=0&locale=en_US ## Expected SLA TP99 1000ms at 100rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations(locale, updated_since, updated_until, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param datetime updated_since: Returns reservations changed since this timestamp as determined by the updatedAt field (updatedAt >= updatedSince). Datetime should be a UTC time and formatted as yyyy-MM-ddTHH:mm:ssZ.  (required)
        :param datetime updated_until: Returns reservations changed until this timestamp as determined by the updatedAt field (updatedAt < updatedUntil). Datetime should be a UTC time and formatted as yyyy-MM-ddTHH:mm:ssZ.  (required)
        :param str status: The current status for this reservation. This represents the current state of the reservation in the reservation lifecycle state machine.
        :param int offset: The starting point of the returned results. For example, if you have a collection of 300 reservations matching the specified query and you specify limit=100, you can retrieve the entire set of results in 3 successive requests by varying the offset value: offset=0, offset=100, and offset=200.
        :param int limit: The maximum number of records that should be returned.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_reservations_with_http_info(locale, updated_since, updated_until, **kwargs)  # noqa: E501
        else:
            (data) = self.get_reservations_with_http_info(locale, updated_since, updated_until, **kwargs)  # noqa: E501
            return data

    def get_reservations_with_http_info(self, locale, updated_since, updated_until, **kwargs):  # noqa: E501
        """Search Reservations  # noqa: E501

        This endpoint is a search endpoint for Groupon to retrieve a collection of relevant reservations matching a specified query. This endpoint will be used by Groupon for post-purchase reservation status reconciliations with partner. This helps to reduce multiple calls to partner on individual reservation with Retrieve Reservation api and consolidating into fewer bulk calls.  The results should be sorted by the reservation updatedAt field in ascending order, then by the id field in ascending order. Sorting will ensure records maintain definite order across pagination queries.  To ensure Groupon polls all the updated reservations with the endpoint, the reservation updatedAt field should be updated by partner when: * Reservation status is updated * ReservedUnits associated with reservation are updated  Note: Groupon will make calls to this endpoint at recurring intervals and paginate over the results if needed.  For example if calling every 10 minutes: t: /groupon/v1/reservations?status=fulfilled&updatedSince=2018-11-04T00:00:00Z&updatedUntil=2018-11-04T00:10:00Z&limit=100&offset=0&locale=en_US t+10min: /groupon/v1/reservations?status=fulfilled&updatedSince=2018-11-04T00:10:00Z&updatedUntil=2018-11-04T00:20:00Z&limit=100&offset=0&locale=en_US ## Expected SLA TP99 1000ms at 100rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations_with_http_info(locale, updated_since, updated_until, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param datetime updated_since: Returns reservations changed since this timestamp as determined by the updatedAt field (updatedAt >= updatedSince). Datetime should be a UTC time and formatted as yyyy-MM-ddTHH:mm:ssZ.  (required)
        :param datetime updated_until: Returns reservations changed until this timestamp as determined by the updatedAt field (updatedAt < updatedUntil). Datetime should be a UTC time and formatted as yyyy-MM-ddTHH:mm:ssZ.  (required)
        :param str status: The current status for this reservation. This represents the current state of the reservation in the reservation lifecycle state machine.
        :param int offset: The starting point of the returned results. For example, if you have a collection of 300 reservations matching the specified query and you specify limit=100, you can retrieve the entire set of results in 3 successive requests by varying the offset value: offset=0, offset=100, and offset=200.
        :param int limit: The maximum number of records that should be returned.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'updated_since', 'updated_until', 'status', 'offset', 'limit']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reservations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `get_reservations`")  # noqa: E501
        # verify the required parameter 'updated_since' is set
        if ('updated_since' not in params or
                params['updated_since'] is None):
            raise ValueError("Missing the required parameter `updated_since` when calling `get_reservations`")  # noqa: E501
        # verify the required parameter 'updated_until' is set
        if ('updated_until' not in params or
                params['updated_until'] is None):
            raise ValueError("Missing the required parameter `updated_until` when calling `get_reservations`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'updated_since' in params:
            query_params.append(('updatedSince', params['updated_since']))  # noqa: E501
        if 'updated_until' in params:
            query_params.append(('updatedUntil', params['updated_until']))  # noqa: E501
        if 'offset' in params:
            query_params.append(('offset', params['offset']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/reservations', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_reservations_id_v2(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Retrieve Reservation  # noqa: E501

        This endpoint is used to retrieve an existing reservation created through a [reserve call](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post) from the Partner.  ## Expected SLA TP99 50ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  Note: The response body is the same as the [Reserve endpoint](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations_id_v2(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_reservations_id_v2_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_reservations_id_v2_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
            return data

    def get_reservations_id_v2_with_http_info(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Retrieve Reservation  # noqa: E501

        This endpoint is used to retrieve an existing reservation created through a [reserve call](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post) from the Partner.  ## Expected SLA TP99 50ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  Note: The response body is the same as the [Reserve endpoint](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_reservations_id_v2_with_http_info(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'reservation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reservations_id_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `get_reservations_id_v2`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `get_reservations_id_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v2/reservations/{reservationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_system_availability(self, **kwargs):  # noqa: E501
        """Heartbeat  # noqa: E501

        This endpoint is a simple health check endpoint for Groupon to monitor system availability. It will be fired periodically by Groupon outside of any purchase transactions to test for any connectivity or availability issues.  ## Expected SLA TP99 10ms at 10krpm  This is just the server response time, and does not include network transit time.  No response body is expected, as HTTP response codes will dictate whether the partner system is considered available or not. In the future, a response body may be added to support passing debug information   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_system_availability(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_system_availability_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_system_availability_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_system_availability_with_http_info(self, **kwargs):  # noqa: E501
        """Heartbeat  # noqa: E501

        This endpoint is a simple health check endpoint for Groupon to monitor system availability. It will be fired periodically by Groupon outside of any purchase transactions to test for any connectivity or availability issues.  ## Expected SLA TP99 10ms at 10krpm  This is just the server response time, and does not include network transit time.  No response body is expected, as HTTP response codes will dictate whether the partner system is considered available or not. In the future, a response body may be added to support passing debug information   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_system_availability_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_system_availability" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/system/availability', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_products_availability_v2(self, body, locale, **kwargs):  # noqa: E501
        """Check Availability  # noqa: E501

        This endpoint is used to determine availability and pricing for a specific product and attribute combination. The availability should be based off of real-time sources.  Optionally, the partner may choose to implement a temporary hold on inventory and return those reserved units in the response. For an iframe integration, the returned reservation ID (called a pre-reservation ID in this call) will be passed as a URL parameter.  A partner which is implementing only iframe transactions will not need to implement this call. However, even if a partner has “unlimited” inventory this endpoint should still be implemented. The reason is that the partner should return a `PRODUCT_NOT_AVAILABLE` error if the product is no longer offered for purchase.  ## Expected SLA TP99 35ms at 10k rpm  This is just the server response time, and does not include network transit time.  ## Request This request is specified as using POST for practical reasons as the full set of inputs may exceed static buffer space for query string size in common server stacks; however, the request should not create data, and the semantics should be the same as GET. The specific attributes supported will expand over time to fit the needs of a specific partner.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_products_availability_v2(body, locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProductsAvailabilityBody1 body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_products_availability_v2_with_http_info(body, locale, **kwargs)  # noqa: E501
        else:
            (data) = self.post_products_availability_v2_with_http_info(body, locale, **kwargs)  # noqa: E501
            return data

    def post_products_availability_v2_with_http_info(self, body, locale, **kwargs):  # noqa: E501
        """Check Availability  # noqa: E501

        This endpoint is used to determine availability and pricing for a specific product and attribute combination. The availability should be based off of real-time sources.  Optionally, the partner may choose to implement a temporary hold on inventory and return those reserved units in the response. For an iframe integration, the returned reservation ID (called a pre-reservation ID in this call) will be passed as a URL parameter.  A partner which is implementing only iframe transactions will not need to implement this call. However, even if a partner has “unlimited” inventory this endpoint should still be implemented. The reason is that the partner should return a `PRODUCT_NOT_AVAILABLE` error if the product is no longer offered for purchase.  ## Expected SLA TP99 35ms at 10k rpm  This is just the server response time, and does not include network transit time.  ## Request This request is specified as using POST for practical reasons as the full set of inputs may exceed static buffer space for query string size in common server stacks; however, the request should not create data, and the semantics should be the same as GET. The specific attributes supported will expand over time to fit the needs of a specific partner.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_products_availability_v2_with_http_info(body, locale, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ProductsAvailabilityBody1 body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'purchaser_id', 'prereservation_id', 'purchaser_email_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_products_availability_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_products_availability_v2`")  # noqa: E501
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `post_products_availability_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'purchaser_id' in params:
            query_params.append(('purchaserId', params['purchaser_id']))  # noqa: E501
        if 'prereservation_id' in params:
            query_params.append(('prereservationId', params['prereservation_id']))  # noqa: E501
        if 'purchaser_email_hash' in params:
            query_params.append(('purchaserEmailHash', params['purchaser_email_hash']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v2/products/availability', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reservations_id_cancellations_v2(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Cancel v2  # noqa: E501

        This endpoint is to transition a reservation in the “reserved” or “fulfilled” state to the “cancelled” state. This indicates that the reservation is now void, and should not be fulfilled or redeemed for the consumer. A variety of circumstances could cause this, but the important distinction for a partner is that it should not allow fulfillment and/or redemption for the customer if at all possible. It is considered valid for this endpoint to be invoked on a reservation for any status; however, not all reservation are allowed to be cancelled (e.g. the reservation type does not allow cancels or the time window for cancellation has elapsed).  Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be “cancelling” or “cancelled”.   ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_cancellations_v2(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reservations_id_cancellations_v2_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reservations_id_cancellations_v2_with_http_info(locale, reservation_id, **kwargs)  # noqa: E501
            return data

    def post_reservations_id_cancellations_v2_with_http_info(self, locale, reservation_id, **kwargs):  # noqa: E501
        """Cancel v2  # noqa: E501

        This endpoint is to transition a reservation in the “reserved” or “fulfilled” state to the “cancelled” state. This indicates that the reservation is now void, and should not be fulfilled or redeemed for the consumer. A variety of circumstances could cause this, but the important distinction for a partner is that it should not allow fulfillment and/or redemption for the customer if at all possible. It is considered valid for this endpoint to be invoked on a reservation for any status; however, not all reservation are allowed to be cancelled (e.g. the reservation type does not allow cancels or the time window for cancellation has elapsed).  Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be “cancelling” or “cancelled”.   ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_cancellations_v2_with_http_info(locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['locale', 'reservation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reservations_id_cancellations_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `post_reservations_id_cancellations_v2`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `post_reservations_id_cancellations_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v2/reservations/{reservationId}/cancellations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reservations_id_fulfillments_v2(self, body, reservation_id, **kwargs):  # noqa: E501
        """Fulfill V2  # noqa: E501

        This endpoint is to transition a reservation in the `reserved` state to the `fulfilled` state. This indicates that the payment has been captured by Groupon, and the reservation is now able to be fulfilled by the partner. The inventory should not be released to the user until it is fulfilled.  It is considered valid for this endpoint to be invoked on a `fulfilled` or `fulfilling` reservation, but not a `cancelled`, `cancelling`, or `reserving` reservation. Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be `fulfilling` or `fulfilled`. The status should be set to `fulfilling` until the inventory has been shipped (for shipping products) or an electronic form is available (for electronic fulfillmentType products). Once this occurs, the status can be changed to the final `fulfilled` status. The important aspect here is that the status should not be set to `fulfilled` unless the inventory has been guaranteed to be available for the purchaser.  ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed. Please note that locale is not required to be passed in this call.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_fulfillments_v2(body, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReservationIdFulfillmentsBody1 body: (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reservations_id_fulfillments_v2_with_http_info(body, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reservations_id_fulfillments_v2_with_http_info(body, reservation_id, **kwargs)  # noqa: E501
            return data

    def post_reservations_id_fulfillments_v2_with_http_info(self, body, reservation_id, **kwargs):  # noqa: E501
        """Fulfill V2  # noqa: E501

        This endpoint is to transition a reservation in the `reserved` state to the `fulfilled` state. This indicates that the payment has been captured by Groupon, and the reservation is now able to be fulfilled by the partner. The inventory should not be released to the user until it is fulfilled.  It is considered valid for this endpoint to be invoked on a `fulfilled` or `fulfilling` reservation, but not a `cancelled`, `cancelling`, or `reserving` reservation. Please refer to the reservation lifecycle state machine for more details about possible state for a reservation.  The status of the reservation after this call should be `fulfilling` or `fulfilled`. The status should be set to `fulfilling` until the inventory has been shipped (for shipping products) or an electronic form is available (for electronic fulfillmentType products). Once this occurs, the status can be changed to the final `fulfilled` status. The important aspect here is that the status should not be set to `fulfilled` unless the inventory has been guaranteed to be available for the purchaser.  ## Expected SLA TP99 35ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  While this request is a POST, there is no request body passed. Please note that locale is not required to be passed in this call.  Note: The response body is the same as the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_fulfillments_v2_with_http_info(body, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReservationIdFulfillmentsBody1 body: (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'reservation_id', 'locale']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reservations_id_fulfillments_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_reservations_id_fulfillments_v2`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `post_reservations_id_fulfillments_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v2/reservations/{reservationId}/fulfillments', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reservations_id_unit_cancellations(self, body, locale, reservation_id, **kwargs):  # noqa: E501
        """Unit Cancel  # noqa: E501

        This endpoint is used to support unit level cancellations, although the whole reservation can be cancelled if all of its units are cancelled. The following scenarios are possible:  1. Customer wants to cancel all the units of the reservation (Full reservation cancellation). This endpoint can be used, sending all    reservedUnits of the reservation. The `/groupon/v1/reservations/{reservationId}/cancellations` endpoint can also be used instead. 2. Customer wants to cancel a subset of the units in a reservation (Partial reservation cancellation), if reservation has more than one unit.    The request body will contain the units in reservedUnits field that the customer wants to cancel.  The state of the requested units should be transitioned to `cancelled`. This endpoint should behave in a transactional manner, that is, if any unit in the request can't be transitioned to `cancelled` the whole request should fail with error code `UNIT_NOT_CANCELLABLE`, and no state transition should happen to any of the units.  If all units of a reservation are in the `cancelled` state, then the state of the reservation should be `cancelled`. Note that unit states changes might happen on multiple API calls.  Please refer to the reservation lifecycle state machine and the unit lifecycle state machine for more details.  Note - If a partner only supports reservation level (full) cancellations, then there is no need to track unit state seperately, however this endpoint can still be implemented and only support full cancellations as described above.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_unit_cancellations(body, locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnitsCancellationsBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reservations_id_unit_cancellations_with_http_info(body, locale, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reservations_id_unit_cancellations_with_http_info(body, locale, reservation_id, **kwargs)  # noqa: E501
            return data

    def post_reservations_id_unit_cancellations_with_http_info(self, body, locale, reservation_id, **kwargs):  # noqa: E501
        """Unit Cancel  # noqa: E501

        This endpoint is used to support unit level cancellations, although the whole reservation can be cancelled if all of its units are cancelled. The following scenarios are possible:  1. Customer wants to cancel all the units of the reservation (Full reservation cancellation). This endpoint can be used, sending all    reservedUnits of the reservation. The `/groupon/v1/reservations/{reservationId}/cancellations` endpoint can also be used instead. 2. Customer wants to cancel a subset of the units in a reservation (Partial reservation cancellation), if reservation has more than one unit.    The request body will contain the units in reservedUnits field that the customer wants to cancel.  The state of the requested units should be transitioned to `cancelled`. This endpoint should behave in a transactional manner, that is, if any unit in the request can't be transitioned to `cancelled` the whole request should fail with error code `UNIT_NOT_CANCELLABLE`, and no state transition should happen to any of the units.  If all units of a reservation are in the `cancelled` state, then the state of the reservation should be `cancelled`. Note that unit states changes might happen on multiple API calls.  Please refer to the reservation lifecycle state machine and the unit lifecycle state machine for more details.  Note - If a partner only supports reservation level (full) cancellations, then there is no need to track unit state seperately, however this endpoint can still be implemented and only support full cancellations as described above.  ## Expected SLA TP99 35ms at 500rpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_id_unit_cancellations_with_http_info(body, locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param UnitsCancellationsBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'reservation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reservations_id_unit_cancellations" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_reservations_id_unit_cancellations`")  # noqa: E501
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `post_reservations_id_unit_cancellations`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `post_reservations_id_unit_cancellations`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/reservations/{reservationId}/units/cancellations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def post_reservations_v2(self, body, locale, purchaser_id, **kwargs):  # noqa: E501
        """Reserve  # noqa: E501

        This endpoint is used to put an indefinite hold on inventory. This can take the form of either a specific unit returned from the check availability call, or a general product. The reserved units should “belong” to the purchaser, and should not expire or be released unless cancel is explicitly called. The inventory should also not be released to the purchaser until it has been fulfilled.  In the case that a previously reserved unit (i.e. a temporary hold from the check availability call) is no longer available, this should be treated as any other availability failure.  The partner is able to verify the price Groupon is charging as it will be passed in the request. Groupon will also verify the price which the partner expected to be charged by comparing it to the price in the response. If Groupon detects an inconsistency, it may automatically cancel the order to avoid incorrectly charging the customer; however, it is recommended that the partner verify the price on the request and fail the request with the appropriate error code.  The status of the reservation after this call should be “reserved”.  ## Expected SLA TP99 80ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_v2(body, locale, purchaser_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2ReservationsBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).  (required)
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.post_reservations_v2_with_http_info(body, locale, purchaser_id, **kwargs)  # noqa: E501
        else:
            (data) = self.post_reservations_v2_with_http_info(body, locale, purchaser_id, **kwargs)  # noqa: E501
            return data

    def post_reservations_v2_with_http_info(self, body, locale, purchaser_id, **kwargs):  # noqa: E501
        """Reserve  # noqa: E501

        This endpoint is used to put an indefinite hold on inventory. This can take the form of either a specific unit returned from the check availability call, or a general product. The reserved units should “belong” to the purchaser, and should not expire or be released unless cancel is explicitly called. The inventory should also not be released to the purchaser until it has been fulfilled.  In the case that a previously reserved unit (i.e. a temporary hold from the check availability call) is no longer available, this should be treated as any other availability failure.  The partner is able to verify the price Groupon is charging as it will be passed in the request. Groupon will also verify the price which the partner expected to be charged by comparing it to the price in the response. If Groupon detects an inconsistency, it may automatically cancel the order to avoid incorrectly charging the customer; however, it is recommended that the partner verify the price on the request and fail the request with the appropriate error code.  The status of the reservation after this call should be “reserved”.  ## Expected SLA TP99 80ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.post_reservations_v2_with_http_info(body, locale, purchaser_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param V2ReservationsBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str purchaser_id: An identifier representing the Groupon user purchasing this option. The format will be a UUID (canonical format).  (required)
        :param str prereservation_id: This would be the data.reservationId attribute returned by the reservationPlaced event for an iframe integration or the meta.prereservationId field from a checkAvailability response.
        :param str purchaser_email_hash: The email hash for the Groupon user purchasing this option. See the Purchaser Email Hash section for more details.  Since not all Groupon users have an associated email address, this field is not required.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'purchaser_id', 'prereservation_id', 'purchaser_email_hash']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method post_reservations_v2" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `post_reservations_v2`")  # noqa: E501
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `post_reservations_v2`")  # noqa: E501
        # verify the required parameter 'purchaser_id' is set
        if ('purchaser_id' not in params or
                params['purchaser_id'] is None):
            raise ValueError("Missing the required parameter `purchaser_id` when calling `post_reservations_v2`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501
        if 'purchaser_id' in params:
            query_params.append(('purchaserId', params['purchaser_id']))  # noqa: E501
        if 'prereservation_id' in params:
            query_params.append(('prereservationId', params['prereservation_id']))  # noqa: E501
        if 'purchaser_email_hash' in params:
            query_params.append(('purchaserEmailHash', params['purchaser_email_hash']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v2/reservations', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def put_reservations_id(self, body, locale, reservation_id, **kwargs):  # noqa: E501
        """Update Reservation  # noqa: E501

        This endpoint updates the reservation details of a reservation previously created through a reserve call. They payload is the same as the Reserve endpoint.  ## Expected SLA TP99 50ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  Note: The request and response body is same of the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_reservations_id(body, locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReservationsReservationIdBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.put_reservations_id_with_http_info(body, locale, reservation_id, **kwargs)  # noqa: E501
        else:
            (data) = self.put_reservations_id_with_http_info(body, locale, reservation_id, **kwargs)  # noqa: E501
            return data

    def put_reservations_id_with_http_info(self, body, locale, reservation_id, **kwargs):  # noqa: E501
        """Update Reservation  # noqa: E501

        This endpoint updates the reservation details of a reservation previously created through a reserve call. They payload is the same as the Reserve endpoint.  ## Expected SLA TP99 50ms at 10krpm  This is just the server response time, and does not include network transit time.  ## Request  Note: The request and response body is same of the [Reserve request](#tag/Endpoint-Definitions/paths/~1groupon~1v1~1reservations/post).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.put_reservations_id_with_http_info(body, locale, reservation_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ReservationsReservationIdBody body: (required)
        :param str locale: The locale and country code which represents the language for the content.  This should use the ISO-3166-1 and UN M.49 variation of the [IETF language tag](https://en.wikipedia.org/wiki/IETF_language_tag#ISO_3166-1_and_UN_M.49).  (required)
        :param str reservation_id: The partner id for the reservation being retrieved. This id is for the reservation in the partner’s system.  (required)
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'locale', 'reservation_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method put_reservations_id" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `put_reservations_id`")  # noqa: E501
        # verify the required parameter 'locale' is set
        if ('locale' not in params or
                params['locale'] is None):
            raise ValueError("Missing the required parameter `locale` when calling `put_reservations_id`")  # noqa: E501
        # verify the required parameter 'reservation_id' is set
        if ('reservation_id' not in params or
                params['reservation_id'] is None):
            raise ValueError("Missing the required parameter `reservation_id` when calling `put_reservations_id`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'reservation_id' in params:
            path_params['reservationId'] = params['reservation_id']  # noqa: E501

        query_params = []
        if 'locale' in params:
            query_params.append(('locale', params['locale']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/groupon/v1/reservations/{reservationId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
